Camp Staff Scheduling Application
This project is currently frozen


## Reflection on My Camp Staff Scheduling Application

### What I Was Trying to Do
I initially set out to create a scheduling program to help streamline staff assignments at the summer camp where I worked. My goal was to:
- Automate the scheduling process
- Reduce conflicts
- Make task assignments more efficient

### How I Designed the System

1. **Breaking Down the Problem**
   - **Task Management:** Creating, sorting, and filtering tasks.
   - **Employee Management:** Assigning availability and tracking schedules.
   - **Scheduling Algorithm:** Matching employees to tasks based on constraints.
   - **User Interface:** Accepting input and displaying schedules.

2. **Algorithm Development**
   - Began with simple first-come-first-serve scheduling, which proved inefficient.
   - Introduced priority-based scheduling to handle more critical tasks first.
   - Implemented windowed tasks for flexible scheduling across multiple time slots.
   - Evolved into a hybrid approach using constraint checking and probability weighting.

3. **Refactoring as I Learned**
   - Moved from procedural-style programming to a more object-oriented approach.
   - Modularized code to simplify debugging and maintenance.
   - Adopted dictionaries over lists for faster, clearer data access.

### What I Did
- Built a functional system that could generate staff schedules based on availability, task importance, and preferences.
- Continued adding features and refining algorithms, making the code increasingly complex.
- Eventually stopped development because:
  1. Core functionality was already achieved.
  2. The project was taking too much time.
  3. I only needed it as a learning experience.
  4. The lack of initial planning caused major inefficiencies.
  5. It became too large and complex for a first project.

### What I Learned

1. **The Challenges of Scope Creep**
   - Adding features beyond the original intent leads to growing complexity.
   - Setting clear, achievable goals helps prevent feature bloat.

2. **Programming Fundamentals & Best Practices**
   - Learned Python from scratch in two months.
   - Understood core concepts like loops, conditionals, data structures.
   - Encountered and resolved common pitfalls (e.g., debugging nested loops, optimizing data handling).

3. **Software Design & Organization**
   - Emphasized modularization for readability and maintenance.
   - Experimented with OOP principles, discovering single-responsibility structures.
   - Underwent multiple rewrites as my knowledge expanded.

4. **Debugging & Optimization**
   - Used debugging tools and systematic testing to find and fix errors.
   - Learned to value readability over micro-optimizations early on.
   - Discovered the power of built-in functions vs. writing custom solutions.

5. **Knowing When to Stop**
   - Not every project needs to be “finished” to be a success.
   - The real value was the learning journey, not a perfect end product.
   - Realized the importance of starting with a clear plan to avoid getting lost in complexity.

### Final Thoughts
This was my first real attempt at a substantial coding project. While the system is incomplete and messy, it met its primary goal of teaching me Python and building my confidence in software development. I learned the hard way that planning is everything, scope creep is real, and sometimes you just need to call a project “done” (enough).

**If you’re curious, feel free to explore the code, borrow ideas, or laugh at my rookie mistakes. Thanks for checking out my journey!**

TODO: Honestly i need to include instructions on how to run and install, but since this is a frozen wip project imma just leave it as is.

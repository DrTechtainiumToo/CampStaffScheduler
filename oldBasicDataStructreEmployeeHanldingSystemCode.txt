def employeeAdjustmentSection():
    """
    makes user adjust employee availabilites.
    Returns a dictionary of unavailable employees with Key: name and Value: [times]
    """
    #LESSON LEARNED I made it expect a keword argument with **, but didn't give it one. Argument needed to be all lowercase?
    """
    Dictionary Comprehensions from Lists:
    Create a dictionary with indexes as keys and list elements as values
    hobby_dict = {i: hobby for i, hobby in enumerate(person["hobbies"])}
    """
    
    unavailableEmployees = {}
    noUnavailabilites = True
    
    #TODO LATE STAGE: make save system. #TODO make this when make user interface
    #make a save system where asks if use same unavail as yesterday, do want to edit???
    #Make a option where can make someon unavailable for whole day, or mark someone unavailable for x amount of time and will remember and mark absent. Have ability to change 
    #Make so that recognize when someone was out previosuly and ask if still unavailble during next program run.
    
    
    
    # People Available for day (Check for exceptions), *also find out partial avialibilites*, prompted earlier to see who is out, Ask if anyone is out.
    def employeeAvailabilityInput(noUnavailabilites):

        def employeeUnavailabilityUserInputPrompt(unavailableEmployees):
            """_summary_
                The unavailableEmployees dict is fine tho because it is mutable.
            Args:
                unavailableEmployees (dict): _description_
            """
            while True: #to make sure user inputs name correctly
                print("\n\nWho?\n")
                unavailableEmployeeName = employee_name_input_auto_completer(employeeNamesList, "User: ") #TODO Y/N SHOULD AKS IF ALL DAY FIRST, maybe make enter between two dates
                if unavailableEmployeeName in employeeNamesList:
                    break
                else:
                    print("ERROR | They don't work here silly. | Not a valid employee name, check your capitalization and spelling.")
            
            print("\nWhen is "+unavailableEmployeeName+" unavailable? (Please affix am/pm to end of the times. Example: 7am, 7:00pm, 11:45am-2pm, 6pm-9pm)\n") #LEARNING CONCEPT - input takes 1 arguments, so if need to put vars in output text concatente the string, use f strings, or str.format(). DON'T do this: tempTime = input("\nWhen is",unavailableEmployeeName,"unavailable?\n\nUser: ")
            tempTime = xyz_input_auto_completer("User: ", dayTimeSlotsKeysList)
            tempTime = multi_time_input_detector_and_converter_employee_unavailability(tempTime,unavailableEmployeeName,unavailableEmployees,list(dayTimeSlots[0].keys())) #CHECK IF ERROR: just used standard instead. dayTimeSlotsKeysList, may have to go back to stand way of making this.
            
            #####TODO REALLY IMPORTANT MAKE AN EXCEPTION DN TRY AGAIN IF THEY ENTER TIME IN WRONG ORDER, OR LIKE ENTER THE START TIME BEFORE END TIME WHICH IS INCOMPUTABLE
            unavailableEmployees.update({unavailableEmployeeName:tempTime}) #UPGRADE: use enumerate and append #dict. ??????
            print("Unavailabilities updated: ", unavailableEmployees[unavailableEmployeeName])
            #print("1 unavailableEmployees dict", unavailableEmployees)

            #TODO COULD FUNCTION OUT PROMPT AND STUFF FOR ASKING UNAVAILABLE TIME BC REPEATS TWICE. idk if really matter
            #loop so can insert as many time slots as needed.
            multipleUnavailbilites = input("\n\nIs that the only time, or is " + unavailableEmployeeName +" unavailable at other times, y or n? \n\nUser: ") #LOOP THIS unitl Y/N
            if multipleUnavailbilites in yesAnswers:
                addEntries = True
                while addEntries == True:
                    print("Current unavailable times: ", unavailableEmployees[unavailableEmployeeName])
                    print("\nWhen is",unavailableEmployeeName,"unavailable? (Please affix am/pm to end of the times. Example: 7am, 7:00pm, 11:45am-2pm, 6pm-9pm. Also 12Hr time values only)\n")
                    while True: #so can cycle thru if fucked up
                        newTime = xyz_input_auto_completer("User: ", dayTimeSlotsKeysList)
                        newTime = newTime.replace(" ","")#WHY incase they put a " " between the time and am/pm. Example: 7:00 am, this would cause problems because the master time list doesnt have spaces, just 8am or 11:45am. 
                        #Also later when ordering/prepping and integrating with main data unavailable emp times are compared to the daysTimes dict whose keys / times are all formated as 8:00pm without spaces. CHECK IF ERROR
                        
                        try: #incase they enter something that fucks everything up    
                            newTime = multi_time_input_detector_and_converter_employee_unavailability(newTime,unavailableEmployeeName,unavailableEmployees,list(dayTimeSlots[0].keys()))
                        except Exception as e:
                            print(f"{Fore.RED}{Style.BRIGHT}ERROR {e}|\nYou probbaly messedup up the unavailbility time input so badly that I couldnt fix it,{Fore.GREEN}{Style.BRIGHT} its okay tho, i'll just restart the input sequence.{Style.RESET_ALL}\nRemember the input needs to be a valid 12hr standard time.\n\nBtw, here is what you inputted that messed it up so badly: ",newTime)
                            continue
                        else:
                            break
                    
                    unavailableEmployees[unavailableEmployeeName].extend(newTime)
                    print("Unavailabilities updated: ", unavailableEmployees[unavailableEmployeeName])
                    
                    enterMoreUnavailableTimes = input("\n\nDo you need to enter more times? (Y/N)\n\nUser: ")
                    if enterMoreUnavailableTimes in noAnswers:
                        addEntries = False
                        break
                    testOutput("2 unavailableEmployees dict", unavailableEmployees)
            else:
                testOutput("TEST | Else thingy past lol",None)
                print(f"\nConfirmed: {unavailableEmployeeName} is unavailable at {unavailableEmployees[unavailableEmployeeName]}.\n")
                testOutput("3 unavailableEmployees dict", unavailableEmployees)
            
        avialLoopBoolean = True
        firstLoopIteration = True
        while avialLoopBoolean == True:
            
            if firstLoopIteration == True:
                anyoneUnavailable = input("\nIs anyone unavailable today?\n\ny or n? \n\nUser: ")
                if anyoneUnavailable in noAnswers:
                    testOutput("TEST | unavailableEmployees", unavailableEmployees)
                    print("\nConfirmed: No unavailabilites.")
                    avialLoopBoolean = False    
                else:
                    employeeUnavailabilityUserInputPrompt(unavailableEmployees)
                    noUnavailabilites = False
                    firstLoopIteration = False
                    
            else:
                testOutput(" -1 TEST | noUnavailabilites var: ", noUnavailabilites)
                print("\nIs anyone else unavailable?\n\nY or N?\n")
                anyoneElse = input("\nUser: ")
                if anyoneElse in noAnswers:
                    print("\nConfirmed: no one else is unavailable.\n")
                    avialLoopBoolean = False
                else:
                    employeeUnavailabilityUserInputPrompt(unavailableEmployees)
        return noUnavailabilites
    
    # --------- User confirms unavailability data entered is correct, and redos any mistakes. 
    
    noUnavailabilites = employeeAvailabilityInput(noUnavailabilites) #calls function, duh
    testOutput("TEST | noUnavailabilites var: ", noUnavailabilites)

    #check if unavialable employees, if not then ignore the following
    if noUnavailabilites == False: #CHECKING IF UNAVAILABILITES CORRECT
        #then have it go over and confirm everyone who is out by printing it
        #ask if mistake and want to repeat
        print("List of unavailable employees & times unavailable at: ")
        print(list(unavailableEmployees.items()))
        listCorrectnessConfirmation = input("\nIs the list correct?\nYes or No?\n\nUser: ")
        if listCorrectnessConfirmation in yesAnswers: #ALL INFO CORRECT
            print("\n\nConfirmed, employee availability data correct!\n\nContinuing to task inputs...\n\n")
        else: #NEED TO CORRECT INFO
            listCorrectnessConfirmation = input("\n\nFixing the mistake(s) requires reentering all of the availability data.\n\nProceed? Yes or No\n\nUser: ")
            if listCorrectnessConfirmation in yesAnswers: #CONFIRM WANT TO RESTART PROCESS TO CORRECT INFO
                print("\nConfirmed, restarting process...\n\n")
                employeeAvailabilityInput(noUnavailabilites)
    else: #ALL INFO CORRECT
        print("\nContinuing to task inputs...")
        print("\n----------------------------------------------------------------------------\n")
        #print("List of Unavailable Employees & Time unavailable at")
    return unavailableEmployees
unavailableEmployees = employeeAdjustmentSection()


#region---------------------------------------- Employee Data Conversion and Formatting Region


# Complicatedly reformats and adds data to unavailableEmployee dictionary so that it can then edit/update the availableEmployee Data to reflect the unavailabilites
unavailableEmployees = {'Yacht': ['7:45am', "9:50am"], 'Shazam': ['3:45pm'],
                        'Fenway': ["5:20pm", "10:00am", "11:00am", "11:45am", "1:45pm"]}  # POTENTIAL TYPE ISSUE, program put inputs in as strings,
#TODO NEEED TO SOORT LIST OF TIMES SO THAT IN INCREASIG ORDER OTHERWISE ASSIGNMENT FUNCTION WONT WORK

availabilitesToChangeForEmployees = []
lengthOfUnavailableEmployees = len(unavailableEmployees)
testOutput("0 lengthOfUnavailableEmployees TEST |: ", lengthOfUnavailableEmployees)
numberOfEmployeesInUnavailableEmployeesDict = lengthOfUnavailableEmployees
global listOfOrderOfUEOfIndexesOfAE
listOfOrderOfUEOfIndexesOfAE = []
availability_timesSum = []
iWUEV = 0
employeeOrderInUnavailableEmployeesDict = 0
while lengthOfUnavailableEmployees > 0:
    employeeNameTemp = list(unavailableEmployees.keys())[iWUEV]
    employeeNameTempValue = iWUEV
    iWUEV += 1
    testOutput("0.5, TEST | iWUEV value: ", iWUEV)
    # employeeNameTemp = keyToListTempUE[0]

    testOutput("1, TEST | employeeNameTemp: ", employeeNameTemp)
    testOutput("TEST | unavailableEmployees: ", unavailableEmployees)

    indexValueX = employeeNamesList.index(employeeNameTemp)
    listOfOrderOfUEOfIndexesOfAE.append(indexValueX)
    testOutput("2, name index value for employeeNamesList TEST |: ", indexValueX)

    availability_times = unavailableEmployees[employeeNameTemp]
    testOutput("3, test PRINT availability_times: ", availability_times)
    availability_timesSum.append(availability_times)

    # miniDict = {employeeNameTemp: indexValueX}
    # for time in availability_times:
    # miniDict[time] = False #availability_list [{[time] = False}] for time in availability_times]


    availability_list = [{time: False} for time in availability_times]
    testOutput("4, TEST | availability_list:  ", availability_list)

    availabilitesToChangeForEmployeesTemp = [
        {employeeNameTempValue: employeeNameTemp, employeeNameTemp: indexValueX, "availability": availability_list}]
    testOutput("5, TEST | PRINT availabilitesToChangeForEmployeesTemp[]: ", availabilitesToChangeForEmployeesTemp)

    availabilitesToChangeForEmployees.extend(availabilitesToChangeForEmployeesTemp)
    testOutput("6, TEST | availabilitesToChangeForEmployees{}: ", availabilitesToChangeForEmployees)

    # maybe make availabilitesToChangeForEmployees really availabilitesToChangeForEmployees, and have the getting of the order and the pair values seperate? Or rename, idk and i dont really care.
    lengthOfUnavailableEmployees -= 1
    testOutput("7, TEST | lengthOfUnavailableEmployees", lengthOfUnavailableEmployees)

    testOutput("8,----- END OF ITERATION OF FOR LOOP -----\n\n", None)
testOutput("TEST | listOfOrderOfUEOfIndexesOfAE: ", listOfOrderOfUEOfIndexesOfAE)
testOutput("TEST | availability_timesSum: ", availability_timesSum)
testOutput("test avial time sums call",availability_timesSum[0][1])
testOutput("config print", listOfOrderOfUEOfIndexesOfAE[0])

#Criticism, in feel like my variables are too long, but better to be discriptive and be able to easily tell what they are and apart from eachother than being to short.
#PURPOSE: To make sure the info from unavailable employees is assigned to the right person in the for assignment loop, have to pre sort listOfOrderOfUEOfIndexesOfAE to be in same order as employeeList


#TODO NEEED TO SORT LIST OF TIMES SO THAT IN INCREASIG ORDER OTHERWISE ASSIGNMETN FUNCTION WONT WORK, may need to rework after data format standarizaton
#TODO STANDARDIZING DATA FOR TIME, INT REF, IN LISTS / KINDA DO I WANT TO DI IT HERE OR LATER
#TODO multi time converter idea, what about multi time stuff?, maybe make a function for that? search for times in stirng answer then split up, convert to int. Then subtract to find diff, then be like oh all these times are invalid and then insert all those times into list so all those slots are invalid.

sortedListOfOrderOfUEOfIndexesOfAE = listOfOrderOfUEOfIndexesOfAE #need for fr loop to continue working properly
unavailableEmployeesIndexInEmployeeNameListAndUnavailableTimesDict = {}
iterAAFY = 0
for x in listOfOrderOfUEOfIndexesOfAE:
    unavailableEmployeesIndexInEmployeeNameListAndUnavailableTimesDict.update({listOfOrderOfUEOfIndexesOfAE[iterAAFY]:availability_timesSum[iterAAFY]})
    iterAAFY+=1
#testOutput("TEST | unavailableEmployeesIndexInEmployeeNameListAndUnavailableTimesDict: ", unavailableEmployeesIndexInEmployeeNameListAndUnavailableTimesDict)


#TODO find better way to cycle thru the keys and update values
#TODO make a uni function for splitting dicts and stuff writing data and put back together like DNA modification
#TODO STAND DATA FORMAT BEOFRE SORTING, CANNOT US TRAD DATE, MAKE 2ND TIMESLOT DICT, ONE FOR TIMES & T/F, OTHER FOR DATA REF INT & STR TIME

timeListToSortAlgo = []
tempTransferDict1 = {}
timeListToSortAlgoDefault = deepcopy(timeListToSortAlgo)
iterAAAH = 0
for person in unavailableEmployeesIndexInEmployeeNameListAndUnavailableTimesDict:
    
    #Step 1 - Detach from dictionary, and convert to int
    timeListToSortAlgo.extend(unavailableEmployeesIndexInEmployeeNameListAndUnavailableTimesDict[person])
    testOutput("TEST | timeListToSortAlgo :", timeListToSortAlgo)
    sizeL = len(timeListToSortAlgo)

    #def convertTimeListStrToInt(list,sizeOfList):
    for index, timeStr in enumerate(timeListToSortAlgo):  #index = index, timeStr = corresponding value
        timeListToSortAlgo[index] = dayTimeSlotsStandardizedStN[timeStr]
        testOutput("TEST | Thingy may be working", timeListToSortAlgo)

    #Step 2 - Sort the list to ascending order
    # Selection sort
    # time complexity O(n*n)
    # sorting by finding min_index
    selectionSort(timeListToSortAlgo, sizeL)
    testOutput('TEST | The array after sorting in Ascending Order by selection sort is:', timeListToSortAlgo)

    #Step 3 - Convert back to str
    for index, timeInt in enumerate(timeListToSortAlgo):  #index = index, timeStr = corresponding value
        timeListToSortAlgo[index] = dayTimeSlotsStandardizedNtS[timeInt]
        testOutput("TEST | REconversion may be working", timeListToSortAlgo)

    #Step 4 - Reattach to dictionary
    unavailableEmployeesIndexInEmployeeNameListAndUnavailableTimesDict[listOfOrderOfUEOfIndexesOfAE[iterAAAH]] = timeListToSortAlgo
    testOutput("TEST | tempTransferDict1 FINAL END", tempTransferDict1)
    testOutput("TEST | unavailableEmployeesIndexInEmployeeNameListAndUnavailableTimesDict FINAL END", unavailableEmployeesIndexInEmployeeNameListAndUnavailableTimesDict)
    #IF LINE ABOVE BREAKS, might be because of this: var & usage eslewhere listOfOrderOfUEOfIndexesOfAE

    #END

    testOutput("TEST | timeListToSortAlgo (BEFORE) reset: ", timeListToSortAlgo)
    timeListToSortAlgo = deepcopy(timeListToSortAlgoDefault) #using a .clear method fucks things up, idk why tho
    testOutput("TEST | timeListToSortAlgo (AFTER) reset: ", timeListToSortAlgo)
    iterAAAH+=1
#unavailableEmployeesIndexInEmployeeNameListAndUnavailableTimesDict = deepcopy(tempTransferDict1)

testOutput("TEST | newly sorted & formatted unavailableEmployeesIndexInEmployeeNameListAndUnavailableTimesDict: ", unavailableEmployeesIndexInEmployeeNameListAndUnavailableTimesDict)
testOutput("TEST | (INDV) unavailableEmployeesIndexInEmployeeNameListAndUnavailableTimesDict: ", unavailableEmployeesIndexInEmployeeNameListAndUnavailableTimesDict[2][0])
testOutput("TEST | length of new dict: ", len(unavailableEmployeesIndexInEmployeeNameListAndUnavailableTimesDict))



# TODO - shit DATA STRUCTURE, need to make time dict so can set to false??? ALSO how take multiple, SOLUTION if entered as 6-7 then all good can interpret that
availableEmployees = []
availEmpCollectiveIter = 0
unavailableEmpNumberIter = 0
unavailableEmpsTimeUnavailableIter = 0
dayTimeSlotsIter = 0 #TODO make csv file for defining timeslots, also counsler ones per village, make column title the day / value, and then the slots numbers.
dayTimeSlotsTemp = deepcopy(dayTimeSlots)  #to hold to reset values that unavail employee changed, but don't nessecarily want changed for nxt employee


#Creates final employee profiles, in avialableEmployees List, and updates avail times for employees you said would be unavialable
for employees in employeeNamesList: #names list keeps them in same order too??
    dayTimeSlots = deepcopy(dayTimeSlotsTemp)
    if dayTimeSlotsIter in listOfOrderOfUEOfIndexesOfAE:  # LEARNING QUESTION what are other ways of saying this?
        for slot in dayTimeSlots:
            for key in list(slot.keys()):
                    if unavailableEmpsTimeUnavailableIter < len(unavailableEmployeesIndexInEmployeeNameListAndUnavailableTimesDict[availEmpCollectiveIter]):
                        if key in unavailableEmployeesIndexInEmployeeNameListAndUnavailableTimesDict[availEmpCollectiveIter][unavailableEmpsTimeUnavailableIter]: #BUG FIXED, unavailableEmpNumberIter &  listOfOrderOfUEOfIndexesOfAE, not line up in order the for loop goes through the employeeNamesList, so I pre sort it before the for loop, alt fix is to make adictionary have this loop go off that but can do later.
                            testOutput("TEST | tripwire, unavailableEmployeesIndexInEmployeeNameListAndUnavailableTimesDict[unavailableEmpNumberIter][unavailableEmpsTimeUnavailableIter]", unavailableEmployeesIndexInEmployeeNameListAndUnavailableTimesDict[availEmpCollectiveIter][unavailableEmpsTimeUnavailableIter]) #KEy error 0 = key does not exist
                            testOutput("Slot key caught: ", [key])
                            slot[key] = False
                            testOutput("TEST | unavailableEmpsTimeUnavailableIter / The list index/number of the current unavailable time in the list of unvailiable times for the current unavailable employee: ", unavailableEmpsTimeUnavailableIter)
                            unavailableEmpsTimeUnavailableIter += 1
                            testOutput("For loop if", slot)
                            #TODO See what more efficent for runtime this try and except things, or just doing an if to make sure the unavailableEmpsTimeUnavailableIter is less / equal to the number of absences /len(unavailableEmpNumberIter) of that employee
                    #except:
                        #unavailableEmpsTimeUnavailableIter = len(unavailableEmployeesIndexInEmployeeNameListAndUnavailableTimesDict[unavailableEmpsTimeUnavailableIter]) #why did I add this again???
        testOutput("test ITEMS", slot)
        unavailableEmpsTimeUnavailableIter = 0
        testOutput("TEST | TWO unavailableEmpsTimeUnavailableIter", unavailableEmpsTimeUnavailableIter)
        unavailableEmpNumberIter+=1
        testOutput( "TEST | unavailableEmpNumberIter / The total number (NOT THE INDEX VALUE) of current unavailable employees cycled: ", unavailableEmpNumberIter, "\nend of IF dayTimeSlotsIter in listOfOrderOfUEOfIndexesOfAE statment")

    newEmployeeDict = ({
    'Name': employeeNamesList[availEmpCollectiveIter],
    'Gender': employeeGenderList[availEmpCollectiveIter],
    'Preferences': ['TrashWater'],
    'Availability': dayTimeSlots,
    })

    availEmpCollectiveIter+=1
    testOutput("TEST | availEmpCollectiveIter", availEmpCollectiveIter)
    dayTimeSlotsIter+=1
    dayTimeSlots = dayTimeSlotsTemp
    testOutput("test loop",newEmployeeDict)
    availableEmployees.append(newEmployeeDict)
dayTimeSlots = deepcopy(dayTimeSlotsTemp)

#This Function was written by chat GPT4, bc I was  curious what a table outlook might look like & i was tried from 2 hours of coding. Thanks Chat GPT 4!
def print_employee_table(employee_dict):
    if not isinstance(employee_dict, dict):
        print("Error: Expected a dictionary as input.")
        return

    key_width = max(len(key) for key in employee_dict.keys()) + 2
    value_width = 50

    print("-" * (key_width + value_width + 3))
    print("Employee Information")
    for key, value in employee_dict.items():
        if isinstance(value, list):
            if key == 'Preferences':
                value_str = ', '.join(value)
            elif key == 'Availability':
                    # Assuming 'Availability' contains a list of dictionaries
                    # Count how many timeslots are True
                if value:  # Check if the list is not empty
                    available_slots = sum(1 for time, available in value[0].items() if available is True)
                    value_str = f"Total Slots: {available_slots}, Details Omitted for Brevity"
                else:
                    value_str = "No Availability Data"
            print(f"{key:>{key_width}} : {value_str:<{value_width}}")
        else:
            print(f"{key:>{key_width}} : {value:<{value_width}}")
    print("-" * (key_width + value_width + 3))

# Iterate through each employee dictionary and print its information
"""for employee_dict in availableEmployees:
    print_employee_table(employee_dict)
    print()"""
testOutput("len(availableEmployees[0]['Availability'][0]):",len(availableEmployees[0]["Availability"][0]))



@timer
def employeeAvailableTimeSlotsSummer(employee_dict): #TODO take into calculations the 7:00am slots and other depenencies, maybe make diff betwen fire water and such
    """takes the availableEmployees Dict & Returns totalTimeSlots, (that are true)"""
    totalTimeSlots = 0
    if not isinstance(employee_dict, list):
        print("Error: Expected a list as input.")
    for employee_dict in availableEmployees:
        if not isinstance(employee_dict, dict):
            print("Error: Expected a dictionary as secondary layer input.")
        for key, value in employee_dict.items():
            if key == "Availability":
                    # Assuming 'Availability' contains a list of dictionaries
                    # Count how many timeslots are True
                if value:  # Check if the list is not empty
                    available_slots = sum(1 for time, available in value[0].items() if available is True)
                    totalTimeSlots += available_slots
                else:
                    value_str = "No Availability Data"
    return totalTimeSlots






print("\n--------------------------------------------------------")

#Calc total task for the day and timeslots available to see if enough room.
#might have to change later depending on how structure data
#TODO redo logic on this eventually to take into account weird stuff like overlap, flagup, and 7:00 am no wakeup
#SCRAP THAT IDEA NOTE work around for times when everyone else is asleep is just for that task to randomly select x amount of employees and make them available for that time and then assign them. WAIT NOT NEEDED
#TODO, if everyone it TRUE availbility by default. It will just assign the tasks needed for that period and leave everyone else alone. Can have default None assigned in a thing to show as blank on final output. idk easy to fix
#SOLVING THE OVERLAP PROB can make an computationally exspensive,(well could only do ones that are duration 1+, bc well we would know there is overlap bc the times are same(lets say for ones that have yet computed its the value of all tasks in that period - total num of employees give the amount of instances take up. can use ahead of time for algo. dont want to compute to many thigns ahead.
#hmmmmmmmmm. Or could just calc ahead of tie on certian days knwo will be overlap and account that way. EASIER ))
#min_num_of_people_equal_remaining_times

#TODO redo
#TODO update with new logic totalAvailEmpTimeSlots = 0 #TODO remove after debug
testOutput("TEST | sum of avail emp timeslots: ", totalAvailEmpTimeSlots)
sum_Day_Duration_Values = task_manager.total_tasks_for_today()
#print("TEST | sum_Day_Duration_Values", sum_Day_Duration_Values)

print(f"{Fore.BLUE}{Style.BRIGHT}QUESTION: Calculating if a scheduling solution is possible.....{Style.RESET_ALL}")
totalAvailEmpTimeSlots -= (4+(1*2)+(1*3)) #IF ERROR CHECK, total swatties -4 on kswat and waterun for 7am, then account for am and pm flagup overlap #TODO take into calculations the 7:00am slots and other depenencies (KSWAT etc)
#TODO give option to see how calc??
print("Total employee time periods available: ", totalAvailEmpTimeSlots)
sum_Day_Duration_Values -= ((1*2)+(1*3)) #IF ERROR CHECK, KSWAT AM overlap * * num of people/freq & PM shift overlap * * num of people/freq
#TODO take into calc the depenencies (KSWAT etc) overlaps. account for overlaps
print("Total time periods needed to complete all of today's tasks: ", sum_Day_Duration_Values)
if totalAvailEmpTimeSlots >= sum_Day_Duration_Values:
    print(f"ANSWER: {Fore.GREEN}{Style.BRIGHT}Scheduling solution is probably possible.{Style.RESET_ALL}\nContinuing to task scheduling and assignment...")
if totalAvailEmpTimeSlots <= sum_Day_Duration_Values:
    print(f"ANSWER: {Fore.RED}{Style.BRIGHT}Scheduling solution probably not possible.{Style.RESET_ALL} See diagnostics & suggestions?, Edit Task load / reconfigure?")
    #TODO MAKE CORRECTION LOGIC
    #TODO Make see diagnostics, solution suggestions, edit task load / reconfigure inputs tools? Maybe break down and show stats of each task?, can do fancy stuff later once the sum functions are fully compelted and main program is complete
print("--------------------------------------------------------\n")
